#include <time.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <unistd.h>
#ifdef HAVE_NUMA
# include <numa.h>
# include <numaif.h>
#endif
#include <assert.h>
#include <sys/time.h>
#include <errno.h>
#include <err.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string.h>


// For thread affinity
#include <sched.h>

#include "mem_alloc.h"

#define CPU 10
#define STRINGIZE(X) #X
#define MSR_FILE(CPU) "/dev/cpu/" STRINGIZE(CPU) "/msr"
#define NUMA_NODE 0
#define NUMA_ALLOC 1 /* Set to one to use numa_alloc */

#define ELEM_TYPE uint64_t

#define ONE addr = (uint64_t *)*addr;
#define FOUR ONE ONE ONE ONE
#define SIXTEEN FOUR FOUR FOUR FOUR
#define THIRTY_TWO SIXTEEN SIXTEEN
#define SIXTY_FOUR THIRTY_TWO THIRTY_TWO

/**
 * Read the given memory region. Several accesses are done in each
 * loop iteration to limit the number of accesses caused by the loop
 * test.
 */
void read_memory(uint64_t *memory, size_t size) {

  // register allocation to avoid having memory loads generated by
  // stack accesses. If addr is in the stack, the line addr =
  // (uint64_t *)*addr is compiled (in pseudo anssembler) to r1 =
  // mem[addr]; r2 = mem[r1]; mem[addr] = r2; When doing the register
  // allocation, the code is ocmpiled to: r2 = mem[r1]; r1 = r2; and
  // we see that in that case we only have one memory load.
  register uint64_t *addr = memory;

  // Also register allocation for the same reason
  register int64_t nb_elem_remaining = size / sizeof(ELEM_TYPE);

  while (nb_elem_remaining > 0) {
    THIRTY_TWO
      nb_elem_remaining -= 32;
  }
}

int main(int argc, char **argv) {

  /**
   * Pin process on core CPU
   */
  cpu_set_t mask;
  CPU_ZERO(&mask);
  CPU_SET(CPU, &mask);
  if (sched_setaffinity(0, sizeof(mask), &mask) == -1) {
    printf("sched_setaffinity failed: %s\n", strerror(errno));
    return -1;
  }

  /**
   * Allocates and fills memory. Because the memory is filled, all its
   * pages are touched and as a consequence, no page faults will occur
   * during the measurement.
   */
  uint64_t *memory;
  size_t size_in_bytes = 64000000;
#ifdef HAVE_NUMA
  numa_available();
  if (numa_available() != -1 && NUMA_ALLOC) {
    memory = numa_alloc_onnode(size_in_bytes, NUMA_NODE);
  } else {
    memory = malloc(size_in_bytes);
  }
#else
    memory = malloc(size_in_bytes);
#endif
  assert(memory);
  memset(memory, -1, size_in_bytes);
  fill_memory(memory, size_in_bytes, access_rand);


  /**
   * Open msr file to get file descriptor.
   */
  char *msrfile = MSR_FILE(CPU);
  int fd = open(msrfile, O_RDWR);
  if (fd == -1) {
    fprintf(stderr, "Couldn't open %s: %s\n", msrfile, strerror(errno));
    return -1;
  }

  /**
   * Clear the first general purpose MSR we'll use to count event.
   */
  off_t gp_cnt = 0xC1;
  uint64_t zero_buf = 0;
  ssize_t res = pwrite(fd, &zero_buf, 8, gp_cnt);
  if (res != 8) {
    fprintf(stderr, "Couldn't clear msr 0xC1: %s\n", strerror(errno));
    return -1;
  }

  /**
   * Program OFFCORE_RSP event
   */
  off_t offcore_rsp_0_msr = 0x1A6;
  uint64_t offcore_rsp_0_value = 0x1033; // REMOTE_CACHE_FWD
  res = pwrite(fd, &offcore_rsp_0_value, 8, offcore_rsp_0_msr);
  if (res != 8) {
    fprintf(stderr, "Couldn't write %" PRIx64 ": %s to 0x1A6 msr\n", offcore_rsp_0_value, strerror(errno));
    return -1;
  }

  /**
   * Start counting by writing to IA32_PERFEVTSEL
   */
  off_t ia32_perfevtsel_msr = 0x186;
  uint64_t ia32_perfevtsel_value = 0x5101b7;
  res = pwrite(fd, &ia32_perfevtsel_value, 8, ia32_perfevtsel_msr);
  if (res != 8) {
    fprintf(stderr, "Couldn't write %" PRIx64 ": %s to 0x186 msr\n", ia32_perfevtsel_value, strerror(errno));
    return -1;
  }

  /**
   * Code to be profiled
   */
  read_memory(memory, size_in_bytes);

  /**
   * Stop counting by writing to IA32_PERFEVTSEL
   */
  ia32_perfevtsel_value = 0x1101b7;
  res = pwrite(fd, &ia32_perfevtsel_value, 8, ia32_perfevtsel_msr);
  if (res != 8) {
    fprintf(stderr, "Couldn't write %" PRIx64 ": %s to 0x186 msr\n", ia32_perfevtsel_value, strerror(errno));
    return -1;
  }

  /**
   * Read the counter
   */
  uint64_t count;
  res = pread(fd, &count, 8, gp_cnt);
  if (res == -1) {
    fprintf(stderr, "Couldn't read 0xC1 msr: %s\n", strerror(errno));
    return -1;
  }
  printf("remote cache count = %" PRIu64 "\n", count);

  return 0;
}
